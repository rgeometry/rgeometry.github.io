extends layout.pug

mixin video(file)
  // Fetch the file locally if possible. Otherwise try BackBlaze. If everything fails,
  // go for GitHub LFS object. LFS bandwidth is limited to 1GiB/month.
  video(mute='' loop='' controls='')
    //source(src='./assets/'+file type='video/mp4')
    //source(src='https://f002.backblazeb2.com/file/rgeometry/'+file type='video/mp4')
    //source(src='https://github.com/rgeometry/rgeometry.github.io/raw/main/assets/'+file type='video/mp4')

mixin playground(hash)
  iframe(src='https://web.rgeometry.org:20443/loader.html?hash=' +hash)

block content
  article
    p
      b RGeometry
      |
      | is a ...
    p
      | Geometry is inherently visual and the rest of this website is
      | devoted to illustrations and animations that highlight how the various algorithms work.
  article#inflate.feature
    h2 \( O(n log n) \) Random Convex Polygons
    div
      p
        | Unlike regular polygons, convex polygons can be efficiently sampled without bias.
        | Mostly useful for testing.
        | Adjust the slider to control the number of vertices.
    div
      //- +video('inflate.mp4')
      +playground('36XCQBE0Yok=')
  //- article#fast-visibility.feature
  //-   h2 \( O(k) \) Visibility
  //-   div
  //-     p
  //-       | Finding the visible parts of a polygon from a given point is a cornerstone in
  //-       | computational geometry. There exists many algorithms but one is of special interest.
  //-       | This algorithm is output-sensitive, meaning that the runtime is dependent not on
  //-       | the size of the input polygon but on the size of the visible area.
  //-     p
  //-       | The animation shows how a polygon is first triangulated, then the triangles are processed
  //-       | and marked in grey while the visibility polygon is outlined in green. The number of
  //-       | processed triangles is limited to those that intersect the final visibility polygon.
  //-   div
  //-     +video('fast_visibility.mp4')
  //- article#convex-hull.feature
  //-   h2 \( O(n \log n) \) Convex Hull
  //-   div
  //-     p
  //-       | A convex hull of a set of points is the smallest convex polygon that contains it.
  //-       | You can think of it as a rubber band that stretches around a collection of points.
  //-     p
  //-       | So, how is this useful? Well, there are many fast algorithms that only work on convex
  //-       | polygons. For example, there&apos;s a fast algorithm for finding the two corners that are
  //-       | furthest away from each other. By first finding the convex hull, we can then use the
  //-       | fast algorithm to find the two extreme points in the set.
  //-     p
  //-       a(href='https://en.wikipedia.org/wiki/Convex_hull') Wikipedia article.
  //-   div
  //-     +video('convexhull.mp4')
  //- article#closest-pair.feature
  //-   h2 \( O(n \log n) \) Closest Pair
  //-   div
  //-     p
  //-       | The closest pair problem for points in the Euclidean plane was among the first geometric
  //-       | problems that were treated at the origins of the systematic study of the computational
  //-       | complexity of geometric algorithms.
  //-     p
  //-       a(href='https://en.wikipedia.org/wiki/Closest_pair_of_points_problem') Wikipedia article.
  //-   div
  //-     +video('closestpair.mp4')
  //- article#random-monotone.feature
  //-   h2 \( O(n \log n) \) Random, Monotone Polygons
  //-   div
  //-     p
  //-       | Monotone polygons have the property that all rays in a certain direction
  //-       | only intersect the polygon in at most two places. These kinds of polygons
  //-       | play a key role in many algorithms such as triangulation and being able
  //-       | to quickly generate random samples helps immensely with testing.
  //-     p
  //-       a(href='https://en.wikipedia.org/wiki/Monotone_polygon') Wikipedia article.
  //-   div
  //-     +video('random_monotone.mp4')
  //- article#bentleyottmann.feature
  //-   h2 \( O((n+k) \log n) \) Line segment intersection
  //-   div
  //-     p
  //-       | Using a brute-force search, finding intersections of \(n\) lines would take \(O(n^2)\) time.
  //-       | Since we often want to find intersections, the Bentley-Ottmann algorithm which significantly
  //-       | improved the efficiency.
  //-     p
  //-       | When is this used? Well, to give good error messages, HGeometry will check polygons
  //-       | for self-intersections immediately when they&apos;re created. This leads to mistakes
  //-       | being spotted sooner rather than later.
  //-     p
  //-       a(href='https://en.wikipedia.org/wiki/Bentley%E2%80%93Ottmann_algorithm') Wikipedia article
  //-   div
  //-     +video('bentleyottmann.mp4')
  //- article#shortest-path.feature
  //-   h2 \( O(n) \) Single-Source Shortest Path
  //-   div
  //-     p
  //-       | Finding the shortest path from a specific corner to all other corners
  //-       | is a key step in many other algorithms. It&apos;s used for computing visibility
  //-       | polygons, inflated polygons, and minimum-link distances.
  //-     p
  //-       | The animation shows the shortest internal path from a green point on the side of a polygon
  //-       | to all other corner points.
  //-     | DOI: 10.1007/BF01840360
  //-     br
  //-   div
  //-     +video('multi.mp4')
